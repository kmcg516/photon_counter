// Example of I2C slave

// 8-bits IO extender controlled from I2C
// (c) 2005, 2008 fpga4fun.com, KNJN LLC
// modified 2011 for simulation in Xilinx ISE 10.1.03 , www.train-z.de, MBL

// Please define one of these before starting synthesis
`define Xilinx
//`define Altera

`timescale 1ns / 1ps

module I2CslaveWith8bitsIO(SDA, SCL, IOout, clk, laser_trigger, pmt1, pmt2, end_sim, c1, c2, c3);
inout SDA;
input SCL;
output [7:0] IOout;

/***************
*Counter Inputs*
***************/
input clk;
input laser_trigger;
input pmt1;
input pmt2;
input end_sim;
input c1;
input c2;
input c3;
/*******************
*End Counter Inputs*
*******************/

/*********************
*Counter Declarations*
*********************/
// Initialize to zero if there are errors
reg [15:0] upper_bound, lower_bound;
reg [15:0] ungated1, gated1, ungated2, gated2, ungated3, gated3;
wire [15:0] temp_ungated1, temp_ungated2, temp_ungated3;
wire [15:0] temp_gated1, temp_gated2, temp_gated3;
assign temp_ungated1 = ungated1;
assign temp_gated1 = gated1;
assign temp_ungated2 = ungated2;
assign temp_gated2 = gated2;
assign temp_ungated3 = ungated3;
assign temp_gated3 = gated3;

// Time
reg [15:0] time_ctr;
//real inc = 4.9;

// Fast clock - 4.9 ns
wire clk_fast;

DCM_SP #(
      .CLKFX_DIVIDE(1),   // Can be any integer from 1 to 32
      .CLKFX_MULTIPLY(17) // Can be any integer from 2 to 32
   ) DCM_SP_inst (
      .CLKFX(clk_fast),   // DCM CLK synthesis out (M/D)
      .CLKIN(clk),   // Clock input (from IBUFG, BUFG or DCM)
      .RST(0)        // DCM asynchronous reset input
   );

/************************
*End Counter Declaration*
************************/

// The 7-bits address that we want for our I2C slave
parameter I2C_ADR = 7'h03;

//////////////////////////
// I2C start and stop conditions detection logic
// That's the "black magic" part of this design...
// We use two wires with a combinatorial loop to detect the start and stop conditions
//  ... making sure these two wires don't get optimized away
`ifdef Xilinx
    BUF mybuf(
		.O(SDA_shadow),
		.I((~SCL | start_or_stop) ? SDA : SDA_shadow)
		);
    BUF SOS_BUF(
		.O(start_or_stop), 
		.I(~SCL ? 1'b0 : (SDA ^ SDA_shadow))
		); 
`else
    wire SDA_shadow = (~SCL | start_or_stop) ? SDA : SDA_shadow /* synthesis keep = 1 */;
    wire start_or_stop = ~SCL ? 1'b0 : (SDA ^ SDA_shadow) /* synthesis keep = 1 */;
`endif

//reg incycle;
reg incycle = 1'b0;  //for simulation MBL
always @(negedge SCL or posedge start_or_stop) 
	if(start_or_stop) incycle <= 1'b0; 
	else if(~SDA) incycle <= 1'b1;

//////////////////////////
// Now we are ready to count the I2C bits coming in
//reg [3:0] bitcnt;  // counts the I2C bits from 7 downto 0, plus an ACK bit
reg [3:0] bitcnt = 4'h0; //for simulation MBL
wire bit_DATA = ~bitcnt[3];  // the DATA bits are the first 8 bits sent
wire bit_ACK = bitcnt[3];  // the ACK bit is the 9th bit sent
//reg data_phase;
reg data_phase = 1'b0; //for simulation MBL

// Flag for second byte of data (0 for 1st byte, 1 for 2nd byte)
reg byte_flag = 1'b0;

// Read and write flags
reg [2:0] read_flag = 3'b000;
reg [2:0] write_flag = 3'b000;

always @(negedge SCL or negedge incycle)
if(~incycle)
begin
    bitcnt <= 4'h7;  // the bit 7 is received first
    data_phase <= 1'b0;
end
else
begin
    if(bit_ACK)
    begin
    	bitcnt <= 4'h7;
    	data_phase <= 1'b1;
    end
    else
    	bitcnt <= bitcnt - 4'h1;
end

// and detect if the I2C address matches our own
wire adr_phase = ~data_phase;
//reg adr_match, op_read, got_ACK;
reg adr_match = 1'b0, op_read = 1'b0 , got_ACK = 1'b0; //for simulation MBL
//reg SDAr;
reg SDAr = 1'b0; //for simulation MBL
always @(posedge SCL) SDAr<=SDA;  // sample SDA on posedge since the I2C spec specifies as low as 0s hold-time on negedge
reg [7:0] mem = 8'h00; 
//reg [7:0] mem = 8'hFF; //for initial read access to slave and simulation MBL
wire op_write = ~op_read;

always @(negedge SCL or negedge incycle)
if(~incycle)
begin
    got_ACK <= 1'b0;
    adr_match <= 1'b1;
    op_read <= 1'b0;
end
else
begin
    if(adr_phase & bitcnt==7 & SDAr!=I2C_ADR[6]) adr_match<=1'b0;
    if(adr_phase & bitcnt==6 & SDAr!=I2C_ADR[5]) adr_match<=1'b0;
    if(adr_phase & bitcnt==5 & SDAr!=I2C_ADR[4]) adr_match<=1'b0;
    if(adr_phase & bitcnt==4 & SDAr!=I2C_ADR[3]) adr_match<=1'b0;
    if(adr_phase & bitcnt==3 & SDAr!=I2C_ADR[2]) adr_match<=1'b0;
    if(adr_phase & bitcnt==2 & SDAr!=I2C_ADR[1]) adr_match<=1'b0;
    if(adr_phase & bitcnt==1 & SDAr!=I2C_ADR[0]) adr_match<=1'b0;
    if(adr_phase & bitcnt==0) op_read <= SDAr;
    if(bit_ACK) got_ACK <= ~SDAr;  // we monitor the ACK to be able to free the bus when the master doesn't ACK during a read operation

    if(adr_match & bit_DATA & data_phase & op_write) mem[bitcnt] <= SDAr;  // memory write
	 
	 /**********************************
	 ***Assign upper and lower bounds***
	 **********************************/
	 
	 // Assign upper bound
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==0) upper_bound[bitcnt] <= SDAr;
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==0 & bitcnt==0) write_flag<=1;
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==1) upper_bound[bitcnt+8] <= SDAr;
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==1 & bitcnt==0) write_flag<=2;
	 
	 //Assign lower bound
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==2) lower_bound[bitcnt] <= SDAr;
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==2 & bitcnt==0) write_flag<=3;
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==3) lower_bound[bitcnt+8] <= SDAr;
	 if(adr_match & bit_DATA & data_phase & op_write & write_flag==3 & bitcnt==0) write_flag<=0;
	 
//	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag) mem <= gated1[7:0];
//	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag) mem <= gated1[15:8];
//	 if(adr_match & bit_DATA & data_phase & ~op_write & bitcnt==0) byte_flag <= ~byte_flag;

//	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag & c1 & ~c2 & ~c3) mem <= gated1[7:0];
//	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag & c1 & ~c2 & ~c3) mem <= gated1[15:8];
//	 
//	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag & ~c1 & c2 & ~c3) mem <= gated2[7:0];
//	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag & ~c1 & c2 & ~c3) mem <= gated2[15:8];
//	 
//	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag & ~c1 & ~c2 & c3) mem <= gated3[7:0];
//	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag & ~c1 & ~c2 & c3) mem <= gated3[15:8];
	 
	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag & c1==1 & c2==0 & c3==0) mem <= gated1[7:0];
	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag & c1==1 & c2==0 & c3==0) mem <= gated1[15:8];
	 
	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag & c1==0 & c2==1 & c3==0) mem <= gated2[7:0];
	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag & c1==0 & c2==1 & c3==0) mem <= gated2[15:8];
	 
	 if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag & c1==0 & c2==0 & c3==1) mem <= gated3[7:0];
	 if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag & c1==0 & c2==0 & c3==1) mem <= gated3[15:8];
	 
	 if(adr_match & bit_DATA & data_phase & ~op_write & bitcnt==0) byte_flag <= ~byte_flag;
end

// and drive the SDA line when necessary.
wire mem_bit_low = ~mem[bitcnt[2:0]];
wire SDA_assert_low = adr_match & bit_DATA & data_phase & op_read & mem_bit_low & got_ACK;
wire SDA_assert_ACK = adr_match & bit_ACK & (adr_phase | op_write);
wire SDA_low = SDA_assert_low | SDA_assert_ACK;
assign SDA = SDA_low ? 1'b0 : 1'bz;



//if(adr_match & bit_DATA & data_phase & ~op_write & !byte_flag) assign mem = upper_bound[7:0];
//if(adr_match & bit_DATA & data_phase & ~op_write & byte_flag) assign mem = upper_bound[15:8];
//if(adr_match & bit_DATA & data_phase & ~op_write & bitcnt==0) assign byte_flag = ~byte_flag;




//assign IOout = mem;
assign IOout = gated1[7:0];

/****************
*Counter Section*
****************/

always @(posedge clk_fast) begin
	if(end_sim) begin
		ungated1 <= ungated1;
		gated1 <= gated1;
		ungated2 <= ungated2;
		gated2 <= gated2;
		ungated3 <= ungated3;
		gated3 <= gated3;
		time_ctr <= time_ctr;
	end
	else if(laser_trigger) begin
		ungated1 <= 0;
		gated1 <= 0;
		ungated2 <= 0;
		gated2 <= 0;
		ungated3 <= 0;
		gated3 <= 0;
		time_ctr <= 0;
	end
	else begin
		if(pmt1) begin
			if((time_ctr >= lower_bound) &&(time_ctr <= upper_bound)) begin
				gated1 <= gated1 + 1;
			end
			ungated1 <= ungated1 + 1;
		end
		if(pmt2) begin
			if((time_ctr >= lower_bound) && (time_ctr <= upper_bound)) begin
				gated2 <= gated2 + 1;
				gated3 <= gated3 + 1;
			end
			ungated2 <= ungated2 + 1;
			ungated3 <= ungated3 + 1;
		end
		if((time_ctr >= 0) && (time_ctr < 65535)) begin
			time_ctr <= time_ctr + 5;
		end
	end
end
/********************
*End Counter Section*
********************/

endmodule
